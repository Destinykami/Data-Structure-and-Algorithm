/*
如果一个字符串满足以下条件，则称其为 美丽字符串 ：

它由英语小写字母表的前 k 个字母组成。
它不包含任何长度为 2 或更长的回文子字符串。
给你一个长度为 n 的美丽字符串 s 和一个正整数 k 。

请你找出并返回一个长度为 n 的美丽字符串，该字符串还满足：在字典序大于 s 的所有美丽字符串中字典序最小。如果不存在这样的字符串，则返回一个空字符串。

对于长度相同的两个字符串 a 和 b ，如果字符串 a 在与字符串 b 不同的第一个位置上的字符字典序更大，则字符串 a 的字典序大于字符串 b 。

例如，"abcd" 的字典序比 "abcc" 更大，因为在不同的第一个位置（第四个字符）上 d 的字典序大于 c 。


Solution : 注意一开始给的s已经是一个美丽字符串。
        不包含长度为2或更长的回文子字符串：s[i]!=s[i-1] and s[i]!=s[i-2]
        从后往前贪心,在最靠后的位置进位，然后判断是否会构成回文

        思维题好难.....
*/

class Solution {
public:
    string smallestBeautifulString(string s, int k) {
        k+='a';
        int n=s.length();
        int i=n-1;  //从最后一个字母开始
        s[i]+=1; //先加一
        while(i<n){
            if(s[i]==k){ //这一位超过了最大可用的字母，于是前一位需要进位
                if(i==0){ //无法进位
                    return "";
                }
                //进位
                s[i]='a';
                i--;
                s[i]+=1;
            }
            else if(i>0&&s[i]==s[i-1]||i>1&&s[i]==s[i-2]){ //判断这一位会不会构成回文，如果会，增大1，回到循环开头去判断是否需要进位
                s[i]+=1;
            }
            else{  //目前不会构成回文，检查后面是否有回文串
                i+=1;
            }
        }
        return s;
    }
};